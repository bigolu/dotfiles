#!/usr/bin/env bash

# This command copies the text from stdin to the clipboard using OSC 52. With this you can even copy text from
# an SSH shell to the host computer's clipboard.

set -eu

if [ -n "${SSH_TTY-}" ]; then
  target_tty="$SSH_TTY"
elif [ -n "${TMUX-}" ]; then
  # resolve target terminal to send escape sequence
  # if we are on remote machine, send directly to SSH_TTY to transport escape sequence
  # to terminal on local machine, so data lands in clipboard on our local machine
  pane_active_tty=$(tmux list-panes -F "#{pane_active} #{pane_tty}" | awk '$1=="1" { print $2 }')
  target_tty="$pane_active_tty"
# This conditional checks if this process is connected to a terminal.
# source: https://stackoverflow.com/a/69088164
elif bash -c ": 1>/dev/tty" 1>/dev/null 2>&1; then
  target_tty='/dev/tty'
# If we don't have a terminal to send the escape sequence to, use the system copy utility. For example, when neovim
# is running headless while embedded in another editor, like vscode.
else
  if uname | grep -q Linux; then
    if command -v wl-copy 1>/dev/null 2>&1; then
      wl-copy
    elif command -v xclip 1>/dev/null 2>&1; then
      xclip -selection clipboard
    else
      echo "Error: Can't find the system clipboard copying utility" 1>&2
    fi
  else 
    # Full path for the current executable
    my_pbcopy="$0"
    # Find the system pbcopy. This is done by finding all the executables on the path with the name 'pbcopy'
    # and picking the first one that isn't mine.
    system_pbcopy="$(which -a pbcopy | grep -v -E "^${my_pbcopy}\$" | head -1)"
    if [ -x "$system_pbcopy" ]; then
      "$system_pbcopy"
    else
      echo "Error: Can't find the system pbcopy" 1>&2
    fi
  fi

  exit
fi

# Get input either from stdin or a file.
#
# Command substitution removes trailing newlines, but I want to keep them so I add a character to the end of the input.
# This way any trailing newlines will no longer be trailing.
input=$(cat "$@"; printf x)
# This returns the input, without the extra character at the end.
get_input () {
  printf %s "$input" | head -c -1
}

inputlen=$( get_input | wc -c )

# https://sunaku.github.io/tmux-yank-osc52.html
# The maximum length of an OSC 52 escape sequence is 100_000 bytes, of which
# 7 bytes are occupied by a "\033]52;c;" header, 1 byte by a "\a" footer, and
# 99_992 bytes by the base64-encoded result of 74_994 bytes of copyable text
maxlen=74994

# warn if exceeds maxlen
if [ "$inputlen" -gt "$maxlen" ]; then
  printf "input is %d bytes too long" "$(( inputlen - maxlen ))" >&2
fi

# build up OSC 52 ANSI escape sequence
esc="\033]52;c;$( get_input | head -c $maxlen | base64 | tr -d '\r\n' )\a"

printf %b "$esc" > "$target_tty"
