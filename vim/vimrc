""" Section: This Stuff Should Stay at the Top
let $VIMHOME = $HOME . '/.vim/'
let g:mapleader = "\<Space>"
" if 'encoding' is set, 'scriptencoding' must be set after it
set encoding=utf8
scriptencoding utf-8

""" Section: General
set confirm
set mouse=a
" enable mouse mode while in tmux
let &ttymouse = has('mouse_sgr') ? 'sgr' : 'xterm2'
set backspace=indent,eol,start
set hidden
set nrformats-=octal
set ttimeout ttimeoutlen=100
set updatetime=500
set clipboard=unnamed
set autoread " Re-read file if it is changed by an external program
set scrolloff=10
set sessionoptions-=blank sessionoptions-=options sessionoptions+=tabpages sessionoptions-=folds
set showcmd
set display+=lastline
set nofoldenable

function! OverrideVimsDefaultFiletypePlugins()
  " there is an ftplugin that is bundled with vim that
  " sets the textwidth to 78 if it is currently 0. This sets it back to 0
  set textwidth=0

  " Vim's default filetype plugins get run after filetype detection is
  " performed (i.e. ':filetype plugin on'). So in order to override
  " settings from vim's filetype plugins, the FileType autocommands
  " need to be registered after filetype detection.
  " Since this function gets called on the VimEnter event, we're
  " certain that filetype detection has already
  " happened. In this case it gets triggered when the plugin manager
  " finishes loading plugins.
  augroup OverrideFiletypePlugins
    autocmd!
    " Use vim help pages for keywordprg in vim files
    autocmd FileType vim setlocal keywordprg=:tab\ help
    " Set a default omnifunc
    autocmd FileType * if &omnifunc == "" | setlocal omnifunc=syntaxcomplete#Complete | endif
  augroup END
endfunction

augroup Miscellaneous
  autocmd!
  " Extend iskeyword for filetypes that can reference CSS classes
  autocmd FileType
    \ css,scss,javascriptreact,typescriptreact,javascript,typescript,sass,postcss
    \ setlocal iskeyword+=-,?,!
  autocmd FileType vim setlocal iskeyword+=:,#
  autocmd FileType tmux setlocal iskeyword+=-
  autocmd BufEnter *
        \ if &ft ==# 'help' && (&columns * 10) / &lines > 31 | wincmd L | endif
  autocmd FileType sh setlocal keywordprg=man
  autocmd VimEnter * call OverrideVimsDefaultFiletypePlugins()
  autocmd CursorHold * execute printf('match WordUnderCursor /\V\<%s\>/', escape(expand('<cword>'), '/\'))
  " After a quickfix command is run, open the quickfix window , if there are results
  autocmd QuickFixCmdPost [^l]* cwindow
  autocmd QuickFixCmdPost l*    lwindow
  " Put focus back in quickfix window after opening an entry
  autocmd FileType qf nnoremap <buffer> <CR> <CR><C-W>p
  " highlight trailing whitespace
  autocmd ColorScheme * highlight ExtraWhitespace ctermbg=red | execute '2match ErrorMsg /\s\+$/'
  " Automatically resize all splits to make them equal when the vim window is
  " resized or a new window is created/closed
  autocmd VimResized,WinNew,WinClosed * wincmd =
  autocmd BufWinEnter * if line2byte(line("$") + 1) > 1000000 | syntax clear | else | :syntax sync fromstart | endif
  autocmd! bufwritepost .vimrc source %
  autocmd! bufwritepost vimrc source ~/.vimrc
augroup END

cnoreabbrev <expr> h getcmdtype() == ":" && getcmdline() == 'h' ? 'tab help' : 'h'

" set swapfile directory
let &directory = $VIMHOME . 'swapfile_dir/'
call mkdir(&directory, "p")

" persist undo history to disk
let &undodir = $VIMHOME . 'undo_dir/'
call mkdir(&undodir, "p")
set undofile

" set backup directory
let &backupdir = $VIMHOME . 'backup_dir/'
call mkdir(&backupdir, "p")
set backup

" tab setup
set expandtab
set autoindent smartindent
set smarttab
set shiftround " Round indent to multiple of shiftwidth (applies to < and >)
let s:tab_width = 2
let &tabstop = s:tab_width
let &shiftwidth = s:tab_width
let &softtabstop = s:tab_width

" Display all highlight groups in a new window
command! HighlightTest so $VIMRUNTIME/syntax/hitest.vim

" tabs
nnoremap <silent> <Leader>c :tabnew<CR>
nnoremap <silent> <C-h> :tabprevious<CR>
nnoremap <silent> <C-l> :tabnext<CR>

inoremap jk <Esc>
nnoremap <silent> <Leader>w :wa<CR>
nnoremap <Leader>x :wqa<CR>

" open new horizontal and vertical panes to the right and bottom respectively
set splitright splitbelow
nnoremap <Leader>\| :vsplit<CR>
nnoremap <Leader>- :split<CR>
" close a window, quit if last window
" also when closing a tab, go to the previously opened tab
nnoremap <silent> <expr> <leader>q  winnr('$') == 1 ? ':exe "q" \| silent! tabn '.g:lasttab.'<CR>' : ':close<CR>'
" track which tab last opened
if !exists('g:lasttab')
  let g:lasttab = 1
endif
autocmd TabLeave * let g:lasttab = tabpagenr()

""" Section: Autocomplete
" show the completion menu even if there is only one suggestion
" when autocomplete gets triggered, no suggestion is selected
" Use popup instead of preview window
set completeopt+=menuone,noselect,popup completeopt-=preview
set complete=.,w,b,u

""" Section: Command line settings
" on first wildchar press (<Tab>), show all matches and complete the longest common substring among them.
" on subsequent wildchar presses, cycle through matches
set wildmenu wildmode=longest:full,full
set cmdheight=2

" automatically go to the end of pasted text
vnoremap <silent> p p`]
nnoremap <silent> p p`]

" select the text that was just pasted
noremap gV `[v`]

" vp doesn't replace paste buffer
function! RestoreRegister()
  let @" = s:restore_reg
  return ''
endfunction
function! s:Repl()
  let s:restore_reg = @"
  return "p@=RestoreRegister()\<cr>"
endfunction
vmap <silent> <expr> p <sid>Repl()

" suspend vim and start a new shell
nnoremap <C-z> :suspend<CR>
inoremap <C-z> <ESC>:suspend<CR>
xnoremap <C-z> <ESC>:suspend<CR>

""" Section: System Mappings
" Map the output of these key combinations to their actual names
imap OB <Down>
imap OA <Up>

""" Section: Line folding / splitting
" Prevents inserting two spaces after punctuation on a join (J)
set nojoinspaces
" Delete comment character when joining commented lines
set formatoptions+=j

""" Section: Motions / Text Objects
set matchpairs+=<:>
" Go to start/end of text object
function! GoStart(type) abort
  normal! `[
endfunction
function! GoEnd(type) abort
  normal! `]
endfunction
nnoremap <silent> gb :set opfunc=GoStart<CR>g@
nnoremap <silent> ge :set opfunc=GoEnd<CR>g@
" move ten lines at a time by holding ctrl and a directional key
noremap <C-j> 10j
noremap <C-k> 10k
nnoremap Y yg_

nnoremap } :keepjumps normal! }<CR>
nnoremap { :keepjumps normal! {<CR>

""" Section: Search
"""" Misc.
" While typing the search query, highlight where the first match would be.
set incsearch
" searching is only case sensitive when the query contains an uppercase letter
set ignorecase smartcase
" show match position in command window, don't show 'Search hit BOTTOM/TOP'
set shortmess-=S shortmess+=s
" Use ripgrep as the grep program, if it's available. Otherwise use the internal
" grep implementation since it's cross-platform
let &grepprg = executable('rg') ? 'rg --vimgrep --smart-case --follow' : 'internal'
" toggle search highlighting
nnoremap <silent> <Leader>/ :set hlsearch!<CR>

"""" Use '/' and '?' search in visual mode
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('y')<Bar>let old_regtype=getregtype('y')<CR>
  \gv"yy/<C-R>=&ic?'\c':'\C'<CR><C-R><C-R>=substitute(
  \escape(@y, '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gVzv:call setreg('y', old_reg, old_regtype)<CR>
vnoremap <silent> # :<C-U>
  \let old_reg=getreg('y')<Bar>let old_regtype=getregtype('y')<CR>
  \gv"yy?<C-R>=&ic?'\c':'\C'<CR><C-R><C-R>=substitute(
  \escape(@y, '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gVzv:call setreg('y', old_reg, old_regtype)<CR>

""" Section: Restore Settings
augroup SaveAndRestoreSettings
  autocmd!
  " Restore session after vim starts. The 'nested' keyword tells vim to fire events
  " normally while this autocmd is executing. By default, no events are fired
  " during the execution of an autocmd to prevent infinite loops.
  let s:session_dir = $VIMHOME . 'sessions/'
  function! RestoreOrCreateSession()
    " We omit the first element in the list since that will always be the path
    " to the vim binary e.g. /usr/local/bin/vim
    if v:argv[1:]->empty()
      call mkdir(s:session_dir, "p")
      let s:session_name =  substitute($PWD, '/', '%', 'g') . '%vim'
      let s:session_full_path = s:session_dir . s:session_name
      let s:session_cmd = filereadable(s:session_full_path) ? "source " : "mksession! "
      execute s:session_cmd . fnameescape(s:session_full_path)
    endif
  endfunction
  autocmd VimEnter * nested call RestoreOrCreateSession()
  " save session before vim exits
  function! SaveSession()
    " Need to do this before we save the window state in the session
    if get(g:, 'is_window_maximized', v:false)
      call ToggleMaximizedWindowAndTrackState()
    endif
    if !empty(v:this_session)
      execute 'mksession! ' . fnameescape(v:this_session)
    endif
  endfunction
  autocmd VimLeavePre * call SaveSession()
augroup END

""" Section: Aesthetics
"""" Misc.
set linebreak
set number relativenumber
set cursorline cursorlineopt=number,line
set laststatus=2
set showtabline=1
set wrap
set listchars=tab:Â¬-,space:Â· " chars to represent tabs and spaces when 'setlist' is enabled
set signcolumn=yes " always show the sign column
let &fillchars = "foldopen: ,fold: ,vert:\u23B9,stl:\u2502,stlnc:\u2502"

" Statusline
function! MyStatusLine()
  let g:is_window_maximized = get(g:, 'is_window_maximized', v:false)
  let l:highlight = v:null
  if g:actual_curwin == win_getid()
    if g:is_window_maximized
      let l:highlight = 'StatusLineStandout'
    else
      let l:highlight = 'StatusLine'
    endif
  else
    let l:highlight = 'StatusLineNC'
  endif
  let l:highlight_text = l:highlight . 'Text'
  let l:highlight = '%#' . l:highlight . '#'
  let l:highlight_text = '%#' . l:highlight_text . '#'

  if &ft ==# 'help'
    let l:special_statusline = 'Help'
  elseif exists('b:NERDTree')
    let l:special_statusline = 'NERDTree'
  elseif &ft ==# 'vim-plug'
    let l:special_statusline = 'Vim Plug'
  endif
  if exists('l:special_statusline')
    return l:highlight_text . ' ' . l:special_statusline . ' ' . l:highlight
  endif

  let l:maximized_window_indicator = (g:is_window_maximized && g:actual_curwin == win_getid()) ? 'â¯ [WINDOW_MAXIMIZED] ' : ''

  return l:highlight_text . ' %h%w%q%t%m%r â¯ Ln %l/%L â¯ Col %c/%{execute("echon col(\"$\") - 1")} ' . l:maximized_window_indicator . l:highlight
endfunction
set statusline=%{%MyStatusLine()%}

"""" colorscheme
autocmd VimEnter * nested colorscheme nord

"""" Block cursor in normal mode, thin line in insert mode, and underline in replace mode
let &t_SI.="\e[5 q" "SI = INSERT mode
let &t_SR.="\e[3 q" "SR = REPLACE mode
let &t_EI.="\e[1 q" "EI = NORMAL mode (ELSE)
function! RestoreCursor()
  " set cursor back to block
  silent execute "!echo -ne '\e[1 q'"
endfunction
function! ResetCursor()
  " reset terminal cursor to blinking bar
  silent execute "!echo -ne '\e[5 q'"
endfunction
augroup Cursor
  autocmd!
  autocmd VimLeave * call ResetCursor()
  autocmd VimSuspend * call ResetCursor()
  autocmd VimResume * call RestoreCursor()
augroup END

" Tabline
function! Tabline()
  let tabline = ''

  " shift tabline over if NERDTree is active on the left side
  if bufname(winbufnr(1)) == 'NERD_tree_1'
    let tabline .= '%#VertSplit#' . repeat(' ', winwidth(1) + 1)
  endif

  for i in range(tabpagenr('$'))
    let tab = i + 1
    let winnr = tabpagewinnr(tab)
    let buflist = tabpagebuflist(tab)
    let bufnr = buflist[winnr - 1]
    let bufname = bufname(bufnr)

    let tabline .= '%' . tab . 'T'
    let tabline .= (tab == tabpagenr() ? '%#TabLineSel# â¯ ' : '%#TabLine# â¯ ')
    let tabline .= (bufname != '' ? fnamemodify(bufname, ':t') : '[No Name]')
    let tabline .= ' '
  endfor
  " If the last tab is active, we don't want the rest of the line to have the
  " active highlight
  let tabline .= '%#TabLine#'

  " shift tabline over if NERDTree is active on the right side
  let l:last_window_number = winnr('$')
  if bufname(winbufnr(l:last_window_number)) == 'NERD_tree_1'
    let tabline .= "%=%#VertSplit#" . repeat(' ', winwidth(l:last_window_number))
  endif

  return tabline
endfunction
set tabline=%!Tabline()

""" Section: Plugins
"""" Plugin Manager Settings
" Install vim-plug if not found
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
  \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
endif
" Install plugins if not found
function! InstallMissingPlugins()
  let l:has_missing_plugins = len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
  if l:has_missing_plugins
    PlugInstall --sync
  endif
endfunction
autocmd VimEnter * nested call InstallMissingPlugins()

"""" Start Plugin Manager
call plug#begin('~/.vim/plugged')

"""" General
" Syntax plugins for practically any language
Plug 'sheerun/vim-polyglot'
" Motions for levels of indentation
Plug 'jeetsukumaran/vim-indentwise'
  map [<Tab> <Plug>(IndentWiseBlockScopeBoundaryBegin)
  map ]<Tab> <Plug>(IndentWiseBlockScopeBoundaryEnd)
" replacement for matchit since matchit wasn't working for me
Plug 'andymass/vim-matchup'
  " Don't display offscreen matches in my statusline or a popup window
  let g:matchup_matchparen_offscreen = {}
" Additional text objects and motions
Plug 'wellle/targets.vim'
Plug 'junegunn/vim-peekaboo'
Plug 'inkarkat/vim-CursorLineCurrentWindow'
Plug 'farmergreg/vim-lastplace'
Plug 'tmux-plugins/vim-tmux'
Plug 'szw/vim-maximizer'
  let g:maximizer_set_default_mapping = 0
  function! ToggleMaximizedWindowAndTrackState()
    let l:window_count_in_current_tab = tabpagewinnr(tabpagenr(), '$')
    if l:window_count_in_current_tab == 1
      return
    endif

    let g:is_window_maximized = get(g:, 'is_window_maximized', v:false)
    if g:is_window_maximized
      execute 'MaximizerToggle'
      let g:is_window_maximized = v:false
    else
      execute 'MaximizerToggle'
      let g:is_window_maximized = v:true
    endif
  endfunction
  nnoremap <silent><C-m> :call ToggleMaximizedWindowAndTrackState()<CR>
  vnoremap <silent><C-m> :call ToggleMaximizedWindowAndTrackState()<CR>gv
  inoremap <silent><C-m> <ESC>:call ToggleMaximizedWindowAndTrackState()<CR>

"""" Autocomplete
Plug 'prabirshrestha/asyncomplete.vim'
  let g:asyncomplete_auto_completeopt = 0
  let g:asyncomplete_auto_popup = 1
  let g:asyncomplete_min_chars = 2
  let g:asyncomplete_matchfuzzy = 0
  inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
  function! s:check_back_space() abort
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~ '\s'
  endfunction
  inoremap <silent><expr> <TAB>
    \ pumvisible() ? "\<C-n>" :
    \ <SID>check_back_space() ? "\<TAB>" :
    \ asyncomplete#force_refresh()
  Plug 'prabirshrestha/asyncomplete-buffer.vim'
    let g:asyncomplete_buffer_clear_cache = 1
    autocmd User asyncomplete_setup
      \ call asyncomplete#register_source(asyncomplete#sources#buffer#get_source_options({
      \ 'name': 'buffer',
      \ 'allowlist': ['*'],
      \ 'events': ['InsertLeave','BufWinEnter','BufWritePost'],
      \ 'completor': function('asyncomplete#sources#buffer#completor'),
      \ }))
  Plug 'prabirshrestha/asyncomplete-file.vim'
    autocmd User asyncomplete_setup
        \ call asyncomplete#register_source(asyncomplete#sources#file#get_source_options({
        \ 'name': 'file',
        \ 'allowlist': ['*'],
        \ 'priority': 10,
        \ 'completor': function('asyncomplete#sources#file#completor')
        \ }))
  Plug 'yami-beta/asyncomplete-omni.vim'
    autocmd User asyncomplete_setup
        \ call asyncomplete#register_source(asyncomplete#sources#omni#get_source_options({
        \ 'name': 'omni',
        \ 'allowlist': ['*'],
        \ 'completor': function('asyncomplete#sources#omni#completor'),
        \ 'config': {
        \   'show_source_kind': 1,
        \ },
        \ }))
  Plug 'Shougo/neco-vim'
    Plug 'prabirshrestha/asyncomplete-necovim.vim'
      autocmd User asyncomplete_setup
          \ call asyncomplete#register_source(asyncomplete#sources#necovim#get_source_options({
          \ 'name': 'necovim',
          \ 'allowlist': ['vim'],
          \ 'completor': function('asyncomplete#sources#necovim#completor'),
          \ }))
  Plug 'prabirshrestha/async.vim'
    Plug 'wellle/tmux-complete.vim'

"""" Coordination between plugins
""""" delimitmate, vim-endwise
" Combine enter key (<CR>) mappings from the plugins above.
" Also, if the popupmenu is visible, but no items are selected, close the
" popup and insert a newline.
imap <expr> <CR>
  \ pumvisible() ?
    \ (complete_info().selected == -1 ? '<C-y><CR>' : '<C-y>') :
    \ delimitMate#WithinEmptyPair() ?
      \ "\<C-R>=delimitMate#ExpandReturn()\<CR>" :
      \ "\<CR>\<Plug>DiscretionaryEnd"

"""" Editing
" Automatically add closing keywords (e.g. function/endfunction in vimscript)
Plug 'tpope/vim-endwise'
  let g:endwise_no_mappings = 1
  " this way endwise triggers on 'o'
  nmap o A<CR>
" Automatically close html tags
Plug 'alvan/vim-closetag'
" Automatically insert closing braces/quotes
Plug 'Raimondi/delimitMate'
  " Given the following line (where | represents the cursor):
  "   function foo(bar) {|}
  " Pressing enter will result in:
  " function foo(bar) {
  "   |
  " }
  let g:delimitMate_expand_cr = 0
" Makes it easier to manipulate brace/bracket/quote pairs by providing commands to do common
" operations like change pair, remove pair, etc.
Plug 'tpope/vim-surround'
" For swapping two pieces of text
Plug 'tommcdo/vim-exchange'
" I use it for more robust substitutions, but it does alot more
Plug 'tpope/vim-abolish'
" Expands Emmet abbreviations to write HTML more quickly
Plug 'mattn/emmet-vim'
  let g:user_emmet_expandabbr_key = '<Leader>e'
  let g:user_emmet_mode='n'
Plug 'airblade/vim-matchquote'
Plug 'tpope/vim-commentary'

" Seamless movement between vim windows and tmux panes.
Plug 'christoomey/vim-tmux-navigator'
  let g:tmux_navigator_no_mappings = 1
  execute "set <M-h>=\eh"
  execute "set <M-j>=\ej"
  execute "set <M-k>=\ek"
  execute "set <M-l>=\el"
  noremap <silent> <M-h> :TmuxNavigateLeft<cr>
  noremap <silent> <M-l> :TmuxNavigateRight<cr>
  noremap <silent> <M-j> :TmuxNavigateDown<cr>
  noremap <silent> <M-k> :TmuxNavigateUp<cr>

" Add icons to the gutter to signify version control changes (e.g. new lines, modified lines, etc.)
Plug 'mhinz/vim-signify'
  nnoremap <Leader>vk :SignifyHunkDiff<CR>

" fzf integration
Plug 'junegunn/fzf'
  let g:fzf_layout = { 'window': { 'width': 1, 'height': 1, 'border': 'none' } }
  " Collection of fzf-based commands
  Plug 'junegunn/fzf.vim'
    nnoremap <silent> <Leader>m :Marks<CR>
    nnoremap <silent> <Leader>h :History:<CR>
    nnoremap <silent> <Leader>/ :Commands<CR>
    nnoremap <silent> <Leader>b :Buffers<CR>
    let g:rg_vim_options = '--vimgrep'
    let g:fzfFindFileCommand = 'rg ' . g:rg_vim_options . ' --files'
    " recursive grep
    function! RipgrepFzf(query, fullscreen)
      let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case -- %s || true'
      let initial_command = printf(command_fmt, shellescape(a:query))
      let reload_command = printf(command_fmt, '{q}')
      let spec = {'options': ['--phony', '--query', a:query, '--bind', 'change:first+reload:'.reload_command, '--prompt', 'lines: ']}
      call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
    endfunction
    command! -nargs=* -bang FindLine call RipgrepFzf(<q-args>, <bang>0)
    nnoremap <Leader>g :FindLine<CR>
    " recursive file search
    command! -bang -nargs=* FindFile call
        \ fzf#run(fzf#wrap({
        \ 'source': g:fzfFindFileCommand.' | tr -d "\017"',
        \ 'sink': 'edit',
        \ 'options': '--ansi --preview "bat --style=numbers,grid --paging=never --terminal-width (math $FZF_PREVIEW_COLUMNS - 2) {} | tail -n +2 | head -n -1" --prompt="' . substitute(getcwd(), $HOME, '~', "") .'/" --keep-right'}))
    nnoremap <Leader>f :FindFile<CR>

"""" File explorer
Plug 'preservim/nerdtree', {'on': 'NERDTreeTabsToggle'}
  augroup NerdTree
    " open/close directories with 'h' and 'l'
    autocmd FileType nerdtree nmap <buffer> l o | nmap <buffer> h o
  augroup END
  let g:NERDTreeMouseMode = 2
  let g:NERDTreeShowHidden = 1
  let g:NERDTreeStatusline = -1
  let g:NERDTreeWinPos = "right"
  " Syncs nerdtree across tabs, but I'm really only using this
  " since it has an option for auto-focusing on the current file
  Plug 'jistr/vim-nerdtree-tabs', {'on': 'NERDTreeTabsToggle'}
    let g:nerdtree_tabs_autofind = 1
    execute "set <M-e>=\ee"
    nnoremap <silent> <M-e> :NERDTreeTabsToggle<CR>

"""" Colorscheme
Plug 'arcticicestudio/nord-vim'
  " Overrides
  augroup NordColorschemeOverrides
    autocmd!
    " MatchParen
    autocmd ColorScheme nord highlight MatchParen ctermfg=blue cterm=underline ctermbg=NONE
    " Transparent SignColumn
    autocmd ColorScheme nord highlight clear SignColumn
    " Transparent vertical split
    autocmd ColorScheme nord highlight VertSplit ctermbg=NONE ctermfg=0
    " statusline colors
    autocmd ColorScheme nord highlight StatusLine ctermfg=DarkCyan ctermbg=NONE cterm=bold
    autocmd ColorScheme nord highlight StatusLineNC ctermfg=DarkGray ctermbg=NONE cterm=bold
    autocmd ColorScheme nord highlight StatusLineText ctermfg=DarkCyan ctermbg=NONE cterm=reverse
    autocmd ColorScheme nord highlight StatusLineNCText ctermfg=DarkGray ctermbg=NONE cterm=reverse
    autocmd ColorScheme nord highlight StatusLineStandout ctermfg=DarkYellow ctermbg=NONE cterm=bold
    autocmd ColorScheme nord highlight StatusLineStandoutText ctermfg=DarkYellow ctermbg=NONE cterm=reverse
    " autocomplete popupmenu
    autocmd ColorScheme nord highlight PmenuSel ctermfg=DarkCyan ctermbg=NONE cterm=reverse,bold
    autocmd ColorScheme nord highlight Pmenu ctermfg=black ctermbg=NONE cterm=reverse,bold
    autocmd ColorScheme nord highlight CursorLine ctermfg=NONE ctermbg=NONE cterm=underline
    " transparent background
    autocmd ColorScheme nord highlight Normal ctermbg=NONE
    autocmd ColorScheme nord highlight NonText ctermbg=NONE
    autocmd ColorScheme nord highlight! link EndOfBuffer NonText
    " relative line numbers
    autocmd ColorScheme nord highlight LineNrAbove ctermfg=0
    autocmd ColorScheme nord highlight! link LineNrBelow LineNrAbove
    autocmd ColorScheme nord highlight WordUnderCursor cterm=underline,bold
    autocmd ColorScheme nord highlight TabLine ctermbg=NONE ctermfg=black cterm=underline
    autocmd ColorScheme nord highlight TabLineSel ctermbg=NONE ctermfg=DarkCyan cterm=underline
    autocmd ColorScheme nord highlight WildMenu ctermfg=DarkCyan ctermbg=NONE cterm=bold,underline
    " This variable contains a list of 16 colors that should be used as the color palette for terminals opened in vim.
    " By unsetting this, I ensure that terminals opened in vim will use the color palette of the
    " terminal emulator in which vim is running
    autocmd ColorScheme nord unlet g:terminal_ansi_colors
    " Have vim only use the 16 color palette of the terminal emulator in which it runs
    autocmd ColorScheme nord set t_Co=16
  augroup END

"""" End Plugin Manager
call plug#end()
