#!/bin/env sh

# A less wrapper that doesn't print extra lines to fill the height of the terminal when the content
# being paged is smaller than the terminal height.
#
# Most of this script was taken from this one: https://github.com/johnmellor/scripts/blob/master/bin/least

# Full path for the current executable.
current_executable="$0"
# Find the real less executable. This is done by finding all the executables on the path with the name 'less'
# and picking the first one that is not this wrapper.
less_executable="$(which -a less | grep -v -E "^${current_executable}\$" | head -1)"
if [ -z "$less_executable" ]; then
  echo 'ERROR: Unable to find the real less executable' >&2
  exit 1
fi

"$less_executable" "$@"
exit

# Needed so less doesn't prevent trap from working.
set -m
# Keeps this script alive when Ctrl+C is pressed in less,
# so we still cat and rm $TMPFILE afterwards.
trap '' EXIT

TXTFILE=$(mktemp 2>/dev/null || mktemp -t 'tmp')

if [ -t 0 ]; then
    # Stdin is a terminal (neither a file nor a pipe); hopefully "$@" contains a
    # filename that less can read into a pipe.
    "$less_executable" "$@" | tee "$TXTFILE" | "$less_executable" "$@"
else
    # Stdin is a file or pipe; pass it directly to tee.
    tee "$TXTFILE" | "$less_executable" "$@"
fi

if echo "$LESS" "$@" | grep -q -E '\-(-chop-long-lines|[a-jl-nq-su-zA-CE-NQ-SU-Z]*S)'; then
    # Don't wrap lines, since --chop-long-lines was passed to less.
    LINECOUNT=$(wc -l < "$TXTFILE")
else
    # Wrap lines like less before counting (the perl regex strips ANSI escapes).
    [ -n "$COLUMNS" ] || COLUMNS=$(tput cols)
    LINECOUNT=$(perl -pe 's/\e\[?.*?[\@-~]//g' "$TXTFILE" | fold -w "$COLUMNS" | wc -l)
fi
[ -n "$LINES" ] || LINES=$(tput lines)
if [ "$LINECOUNT" -lt "$LINES" ]; then
    cat "$TXTFILE"
fi

rm "$TXTFILE"
